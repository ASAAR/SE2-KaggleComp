# Digit Recognition Module

# Standard scientific Python imports
import matplotlib

matplotlib.use('Agg')  # Force matplotlib to not use any Xwindows backend (causes errors)
import matplotlib.pyplot as plt
from sklearn import datasets, svm, metrics  # Import datasets, classifiers and performance metrics
import skimage.io
import os  # directories
import imghdr  # image file recognition
import numpy  # numpy arrays

imgfiles = ['rgb', 'gif', 'pbm', 'pgm', 'ppm', 'tiff', 'rast', 'xbm', 'jpeg', 'jpg', 'bmp', 'png', 'webp', 'exr']
path = "/mnt/c/Users/Tayo/Documents/SE2CS4365/HandWrittenChar/eggChar/mnist_jpgfiles/trainsmall/"


# the init function will enter the paths given, which contain the images needed for testing and training
# init will put them into the format needed for the classifier, and return a tuple of two lists
# corresponding to the testing and training data
# returns a zipped list, where element[0] is the testing data and [1] is the training data
# unzip to get both the images and the predictions
def init(path):
    img_array = []
    target_array = []
    dirs = os.listdir(path)  # store the path.
    path_length = len(path)

    for item in dirs:
        if imghdr.what(path + item) in imgfiles:  # if the file has the correct type
            str_path, ext = os.path.splitext(path + item)  # store the filepath in a string in strpath
            img_array.append(skimage.io.imread(str_path + ext))  # add image to img_array
            target_str = str_path[path_length:]  # build the target array to correspond with image collection
            target_str = target_str[:7]
            target_int = int(target_str[-1:])  # get the number that the img represents from the filename
            target_array.append(target_int)  # append to target_array

    # Build the matrix of rows x features
    n_samples = len(img_array)
    features = 28 * 28  # size of image
    row_array = []
    matrix = []

    for member in (img_array):  # build the matrix
        row_array = numpy.reshape(member, (features))
        matrix.append(row_array)

    # randomize the data
    a = tuple(matrix)
    b = tuple(target_array)
    zip_list = list(zip(a, b))  # tie each entry in the matrix to its prediction value
    numpy.random.shuffle(zip_list)  # randomize
    # rand_matrix, rand_digits = zip(*zip_list)  # unzip the randomized list
    print(zip_list[-1:])
    rand_matrix, rand_digits = zip(*zip_list)
    rand_digits = list(rand_digits)
    rand_matrix = list(rand_matrix)
    print(rand_digits[-1:])
    print(rand_matrix[-1:])

    train_int = int(0.7 * n_samples)  # amt of data for training
    test_int = n_samples - train_int  # amt of data for testing

    train_data = zip_list[:test_int]  # 70% of the data stored in train_data
    test_data = zip_list[-test_int:]  # 30% of the data stored in test_data

    # return a tuple of zipped lists
    return train_data, test_data


# Given a data in the form of a tuple of two zipped lists (each image is paired with its classification)
# and each list corresponds to testing & training data,
# This function creates a SVM classifier, fits the data using the training data
# and returns a tuple of two lists - one list is the prediction, one is the actual value.
def predict_images(class_data):
    train_data, test_data = class_data[0], class_data[1]  # get testing & training data
    matrix_train_tup, digits_train_tup = zip(*train_data)  # unzip the randomized training list
    matrix_train = list(matrix_train_tup)
    digits_train = list(digits_train_tup)

    # print(matrix_train[-2:])
    # matrix_train = matrix_train.tolist()

    ##    np_train_mtx = numpy.array(matrix_train)
    ##    np_train_dgt = numpy.array(digits_train)
    ##    np_train_mtx.reshape(1, -1)
    ##    np_train_dgt.reshape(1, -1)

    # numpy.reshape(np_train_mtx, len(np_train_mtx)) #get into numpy format for clasifier
    # numpy.reshape(np_train_dgt, len(np_train_dgt))

    # Create a classifier: a support vector classifier
    classifier = svm.SVC(C=1.0, tol=1e-10, cache_size=600, kernel='rbf', gamma=0.00000001,
                         class_weight='auto')  # C=1.0, gamma=0.001)

    # Classify the Training Data with the fit() function
    # print(matrix_train[-5:])
    # print(digits_train[-5:])
    classifier.fit(matrix_train, digits_train)

    # Get the prediction list using the testing data
    matrix_test_tup, digits_test_tup = zip(*test_data)  # unzip the randomized testing list
    matrix_test = list(matrix_test_tup)
    digits_test = list(digits_test_tup)

    # matrix_test = matrix_test.numpy.tolist()

    np_test_mtx = numpy.array(matrix_test)
    np_test_dgt = numpy.array(digits_test)
    np_test_mtx.reshape(1, -1)
    np_test_dgt.reshape(1, -1)

    print(matrix_test[-2:])

    expected = digits_test
    predicted = classifier.predict(matrix_test)

    # for img_mtx in matrix_test:
    #    predicted.append(classifier.predict(img_mtx))

    print(predicted[-20:])
    print(expected[-20:])
    print("Predict the last image.")
    # print(classifier.predict(matrix_test[-1:]))
    print(predicted[-1:])
    print("Get actual last image.")
    print(digits_test[-1:])

    # print("Classification report for classifier %s:\n%s\n"
    #  % (classifier, metrics.classification_report(expected, predicted)))

    return predicted, expected


# takes in the tuple of lists from predict_images() function
# and scores them
# def score_image():

path = "/mnt/c/Users/Tayo/Documents/SE2CS4365/HandWrittenChar/eggChar/mnist_jpgfiles/trainsmall/"
predict_images(init(path))
